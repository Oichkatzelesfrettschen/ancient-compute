-- Egyptian Multiplication in System F (Polymorphic Lambda Calculus)
-- ==================================================================
--
-- Historical Context:
-- System F, developed by Jean-Yves Girard (1972) and independently by
-- John Reynolds (1974), provides a foundation for polymorphic type systems.
-- Here we implement the ancient Egyptian algorithm (c. 2000 BCE) in this
-- modern theoretical framework, bridging 4,000 years of mathematical thought.
--
-- System F extends simply-typed lambda calculus with universal quantification
-- over types (∀), enabling parametric polymorphism. This implementation shows
-- how ancient algorithms can be expressed in the most fundamental type theories.
--
-- The Egyptian multiplication algorithm demonstrates that core computational
-- insights transcend their representation - from hieroglyphs to type theory.

-- Type definitions
-- Nat is encoded as Church numerals with type ∀α. (α → α) → α → α
type Nat = ∀α. (α → α) → α → α

-- Boolean type
type Bool = ∀α. α → α → α

-- Pair type for representing steps
type Pair α β = ∀γ. (α → β → γ) → γ

-- List type for accumulating steps
type List α = ∀β. (α → β → β) → β → β

-- Church encoding of natural numbers
let zero : Nat =
  Λα. λf: α → α. λx: α. x

let one : Nat =
  Λα. λf: α → α. λx: α. f x

let two : Nat =
  Λα. λf: α → α. λx: α. f (f x)

let succ : Nat → Nat =
  λn: Nat. Λα. λf: α → α. λx: α. f (n [α] f x)

-- Boolean operations
let true : Bool =
  Λα. λt: α. λf: α. t

let false : Bool =
  Λα. λt: α. λf: α. f

let if : ∀α. Bool → α → α → α =
  Λα. λb: Bool. λt: α. λf: α. b [α] t f

let and : Bool → Bool → Bool =
  λp: Bool. λq: Bool. p [Bool] q false

let or : Bool → Bool → Bool =
  λp: Bool. λq: Bool. p [Bool] true q

let not : Bool → Bool =
  λb: Bool. b [Bool] false true

-- Pair operations
let pair : ∀α. ∀β. α → β → Pair α β =
  Λα. Λβ. λx: α. λy: β. Λγ. λf: α → β → γ. f x y

let fst : ∀α. ∀β. Pair α β → α =
  Λα. Λβ. λp: Pair α β. p [α] (λx: α. λy: β. x)

let snd : ∀α. ∀β. Pair α β → β =
  Λα. Λβ. λp: Pair α β. p [β] (λx: α. λy: β. y)

-- List operations
let nil : ∀α. List α =
  Λα. Λβ. λcons: α → β → β. λnil: β. nil

let cons : ∀α. α → List α → List α =
  Λα. λhead: α. λtail: List α.
    Λβ. λcons: α → β → β. λnil: β.
      cons head (tail [β] cons nil)

-- Arithmetic operations needed for Egyptian multiplication
let add : Nat → Nat → Nat =
  λm: Nat. λn: Nat.
    Λα. λf: α → α. λx: α. m [α] f (n [α] f x)

let mult : Nat → Nat → Nat =
  λm: Nat. λn: Nat.
    Λα. λf: α → α. m [α] (n [α] f)

let double : Nat → Nat =
  λn: Nat. add n n

let isZero : Nat → Bool =
  λn: Nat. n [Bool] (λx: Bool. false) true

let isEven : Nat → Bool =
  λn: Nat. n [Bool] not true

let isOdd : Nat → Bool =
  λn: Nat. not (isEven n)

-- Primitive recursion combinator for natural numbers
let natRec : ∀α. α → (Nat → α → α) → Nat → α =
  Λα. λbase: α. λstep: Nat → α → α. λn: Nat.
    snd [Nat] [α] (n [Pair Nat α]
      (λp: Pair Nat α.
        pair [Nat] [α]
          (succ (fst [Nat] [α] p))
          (step (fst [Nat] [α] p) (snd [Nat] [α] p)))
      (pair [Nat] [α] zero base))

-- Division by 2 (shift right)
let halve : Nat → Nat =
  λn: Nat.
    natRec [Nat] zero
      (λi: Nat. λacc: Nat. if [Nat] (isEven i) (succ acc) acc)
      n

-- Egyptian Multiplication Algorithm (Core Implementation)
-- This is the heart of the algorithm in System F
let egyptianMultiply : Nat → Nat → Nat =
  λa: Nat. λb: Nat.
    -- Use primitive recursion to implement the algorithm
    natRec [Pair Nat Nat]
      (pair [Nat] [Nat] zero a)  -- Initial: (accumulator, left)
      (λstep: Nat. λstate: Pair Nat Nat.
        let acc = fst [Nat] [Nat] state in
        let left = snd [Nat] [Nat] state in
        let newAcc = if [Nat] (isOdd b) (add acc left) acc in
        let newLeft = double left in
        pair [Nat] [Nat] newAcc newLeft)
      b
    |> fst [Nat] [Nat]  -- Extract accumulator from final state

-- Alternative recursive implementation using fixed-point combinator
-- Y combinator for general recursion (simplified for this context)
let fix : ∀α. ((α → α) → (α → α)) → α → α =
  Λα. λf: (α → α) → (α → α).
    (λx: (∀β. β → (α → α)). f (λy: α. x [α] x y))
    (λx: (∀β. β → (α → α)). f (λy: α. x [α] x y))

-- Egyptian multiplication using fixed-point recursion
let egyptianMultiplyRec : Nat → Nat → Nat =
  fix [Nat → Nat → Nat → Nat]
    (λrec: Nat → Nat → Nat → Nat.
      λleft: Nat. λright: Nat. λacc: Nat.
        if [Nat] (isZero right)
          acc
          (rec (double left)
               (halve right)
               (if [Nat] (isOdd right) (add acc left) acc)))

-- Type for multiplication steps (for visualization)
type Step = Pair Nat (Pair Nat (Pair Bool Nat))
-- Represents: (left, (right, (included, sum)))

-- Create a step
let mkStep : Nat → Nat → Bool → Nat → Step =
  λl: Nat. λr: Nat. λinc: Bool. λs: Nat.
    pair [Nat] [Pair Nat (Pair Bool Nat)]
      l (pair [Nat] [Pair Bool Nat]
          r (pair [Bool] [Nat] inc s))

-- Verbose version that collects steps
let egyptianMultiplyVerbose : Nat → Nat → Pair Nat (List Step) =
  λa: Nat. λb: Nat.
    natRec [Pair Nat (Pair Nat (List Step))]
      (pair [Nat] [Pair Nat (List Step)]
        zero
        (pair [Nat] [List Step] a (nil [Step])))
      (λn: Nat. λstate: Pair Nat (Pair Nat (List Step)).
        let acc = fst [Nat] [Pair Nat (List Step)] state in
        let leftAndSteps = snd [Nat] [Pair Nat (List Step)] state in
        let left = fst [Nat] [List Step] leftAndSteps in
        let steps = snd [Nat] [List Step] leftAndSteps in
        let included = isOdd b in
        let newAcc = if [Nat] included (add acc left) acc in
        let newStep = mkStep left b included newAcc in
        pair [Nat] [Pair Nat (List Step)]
          newAcc
          (pair [Nat] [List Step]
            (double left)
            (cons [Step] newStep steps)))
      b
    |> λresult: Pair Nat (Pair Nat (List Step)).
        pair [Nat] [List Step]
          (fst [Nat] [Pair Nat (List Step)] result)
          (snd [Nat] [List Step]
            (snd [Nat] [Pair Nat (List Step)] result))

-- Properties as types (Curry-Howard correspondence)
-- These are type signatures for proofs we could construct

-- Correctness: egyptianMultiply a b = mult a b
type Correctness = ∀a: Nat. ∀b: Nat.
  Equal Nat (egyptianMultiply a b) (mult a b)

-- Commutativity: egyptianMultiply a b = egyptianMultiply b a
type Commutativity = ∀a: Nat. ∀b: Nat.
  Equal Nat (egyptianMultiply a b) (egyptianMultiply b a)

-- Identity: egyptianMultiply a one = a
type Identity = ∀a: Nat.
  Equal Nat (egyptianMultiply a one) a

-- Zero property: egyptianMultiply a zero = zero
type ZeroProperty = ∀a: Nat.
  Equal Nat (egyptianMultiply a zero) zero

-- Higher-order version: create multiplier functions
let makeMultiplier : Nat → (Nat → Nat) =
  λn: Nat. λx: Nat. egyptianMultiply n x

-- Polymorphic version that works with any numeric type
-- (assuming appropriate type class constraints)
let egyptianMultiplyPoly : ∀α. (α → α → α) → (α → α) → (α → Bool) → α → α → α =
  Λα. λadd: α → α → α. λdouble: α → α. λisOdd: α → Bool.
    λa: α. λb: α.
      -- Implementation would require more infrastructure
      -- This shows the polymorphic signature
      a  -- Placeholder

-- Example computations (would evaluate at compile time in a real System F implementation)
let thirteen = succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ (succ zero))))))))))) : Nat
let seventeen = succ (succ (succ (succ thirteen))) : Nat

-- 13 × 17 = 221
let result = egyptianMultiply thirteen seventeen : Nat

-- Create a multiplier for 7
let timesSeven = makeMultiplier (succ (succ (succ (succ (succ (succ one)))))) : Nat → Nat

-- Historical examples encoded in types
-- These demonstrate how ancient algorithms can be expressed in modern type theory

-- Example from Rhind Papyrus: powers of 7
let sevenSquared = egyptianMultiply
  (succ (succ (succ (succ (succ (succ one))))))
  (succ (succ (succ (succ (succ (succ one)))))) : Nat

-- Binary decomposition as a type-level computation
type BinaryDecomp n = List (PowerOfTwo n)
-- Would decompose n into sum of powers of 2

-- Main demonstration (in an actual System F implementation)
-- This would print results, but System F is purely functional
let main : Unit =
  -- System F doesn't have I/O, but we can structure the computation
  let testCases = cons [Pair Nat Nat]
    (pair [Nat] [Nat] thirteen seventeen)
    (cons [Pair Nat Nat]
      (pair [Nat] [Nat] (succ (succ (succ (succ (succ zero))))) (succ (succ (succ (succ (succ (succ one)))))))
      (nil [Pair Nat Nat])) in

  -- Process test cases (conceptually)
  testCases [Unit]
    (λtest: Pair Nat Nat. λrest: Unit.
      let a = fst [Nat] [Nat] test in
      let b = snd [Nat] [Nat] test in
      let result = egyptianMultiply a b in
      unit)  -- Would output result in a real implementation
    unit

-- Commentary on System F and Ancient Mathematics
-- ===============================================
--
-- This System F implementation of Egyptian multiplication demonstrates:
--
-- 1. TYPE ABSTRACTION: The algorithm can be abstracted over types using ∀,
--    showing how ancient insights apply to any numeric representation.
--
-- 2. CHURCH ENCODING: Natural numbers as functions (Church numerals) connect
--    to the Egyptian view of numbers as iterative processes.
--
-- 3. CURRY-HOWARD: Types are propositions, programs are proofs. The correctness
--    of Egyptian multiplication can be expressed as a type.
--
-- 4. PARAMETRIC POLYMORPHISM: The algorithm works for any type with appropriate
--    operations, not just specific number representations.
--
-- 5. THEORETICAL FOUNDATIONS: From Egyptian papyri to System F, we see the
--    continuity of mathematical thought across millennia.
--
-- 6. COMPILATION: In a real System F implementation, much of this computation
--    would happen at compile time through type-level evaluation.
--
-- The Egyptian scribes discovered an algorithm so fundamental that it can be
-- expressed in the most abstract type theories we have developed.